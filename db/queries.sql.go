// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package db

import (
	"context"
)

const addTweet = `-- name: AddTweet :one
INSERT INTO tweets (author, content)
VALUES (?, ?)
RETURNING tweet_id
`

type AddTweetParams struct {
	Author  string
	Content string
}

func (q *Queries) AddTweet(ctx context.Context, arg AddTweetParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addTweet, arg.Author, arg.Content)
	var tweet_id int64
	err := row.Scan(&tweet_id)
	return tweet_id, err
}

const bookmarkTweet = `-- name: BookmarkTweet :exec
INSERT INTO bookmarks (username, tweet_id)
VALUES (?, ?)
`

type BookmarkTweetParams struct {
	Username string
	TweetID  int64
}

func (q *Queries) BookmarkTweet(ctx context.Context, arg BookmarkTweetParams) error {
	_, err := q.db.ExecContext(ctx, bookmarkTweet, arg.Username, arg.TweetID)
	return err
}

const deleteTweet = `-- name: DeleteTweet :exec
DELETE FROM tweets
WHERE tweet_id = ?
AND author = ?
`

type DeleteTweetParams struct {
	TweetID int64
	Author  string
}

func (q *Queries) DeleteTweet(ctx context.Context, arg DeleteTweetParams) error {
	_, err := q.db.ExecContext(ctx, deleteTweet, arg.TweetID, arg.Author)
	return err
}

const getBookmarkedTweets = `-- name: GetBookmarkedTweets :many
SELECT tweets.tweet_id, tweets.author, tweets.content, tweets.created, tweets.like_count, likes.username IS NOT NULL AS likedByUser
FROM tweets
LEFT JOIN likes ON likes.username = ? AND tweets.tweet_id = likes.tweet_id
WHERE tweets.tweet_id IN (SELECT tweet_id FROM bookmarks WHERE bookmarks.username = ?)
`

type GetBookmarkedTweetsParams struct {
	Username   string
	Username_2 string
}

type GetBookmarkedTweetsRow struct {
	Tweet       Tweet
	Likedbyuser bool
}

func (q *Queries) GetBookmarkedTweets(ctx context.Context, arg GetBookmarkedTweetsParams) ([]GetBookmarkedTweetsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBookmarkedTweets, arg.Username, arg.Username_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookmarkedTweetsRow
	for rows.Next() {
		var i GetBookmarkedTweetsRow
		if err := rows.Scan(
			&i.Tweet.TweetID,
			&i.Tweet.Author,
			&i.Tweet.Content,
			&i.Tweet.Created,
			&i.Tweet.LikeCount,
			&i.Likedbyuser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikeCount = `-- name: GetLikeCount :one
SELECT like_count FROM tweets
WHERE tweet_id = ?
`

func (q *Queries) GetLikeCount(ctx context.Context, tweetID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getLikeCount, tweetID)
	var like_count int64
	err := row.Scan(&like_count)
	return like_count, err
}

const getLikedTweets = `-- name: GetLikedTweets :many
SELECT tweets.tweet_id, tweets.author, tweets.content, tweets.created, tweets.like_count, bookmarks.username IS NOT NULL AS bookmarkedByUser
FROM tweets
LEFT JOIN bookmarks ON bookmarks.username = ? AND tweets.tweet_id = bookmarks.tweet_id
WHERE tweets.tweet_id IN (SELECT tweet_id FROM likes WHERE likes.username = ?)
`

type GetLikedTweetsParams struct {
	Username   string
	Username_2 string
}

type GetLikedTweetsRow struct {
	Tweet            Tweet
	Bookmarkedbyuser bool
}

func (q *Queries) GetLikedTweets(ctx context.Context, arg GetLikedTweetsParams) ([]GetLikedTweetsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLikedTweets, arg.Username, arg.Username_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLikedTweetsRow
	for rows.Next() {
		var i GetLikedTweetsRow
		if err := rows.Scan(
			&i.Tweet.TweetID,
			&i.Tweet.Author,
			&i.Tweet.Content,
			&i.Tweet.Created,
			&i.Tweet.LikeCount,
			&i.Bookmarkedbyuser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeline = `-- name: GetTimeline :many
SELECT tweets.tweet_id, tweets.author, tweets.content, tweets.created, tweets.like_count, likes.username IS NOT NULL AS likedByUser, bookmarks.username IS NOT NULL AS bookmarkedByUser
FROM tweets
LEFT JOIN likes ON likes.username = ? AND tweets.tweet_id = likes.tweet_id
LEFT JOIN bookmarks ON bookmarks.username = ? AND tweets.tweet_id = bookmarks.tweet_id
WHERE tweets.author LIKE ?
AND tweets.tweet_id < ?
ORDER BY tweets.tweet_id DESC
LIMIT 10
`

type GetTimelineParams struct {
	Username   string
	Username_2 string
	Author     string
	TweetID    int64
}

type GetTimelineRow struct {
	Tweet            Tweet
	Likedbyuser      bool
	Bookmarkedbyuser bool
}

func (q *Queries) GetTimeline(ctx context.Context, arg GetTimelineParams) ([]GetTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, getTimeline,
		arg.Username,
		arg.Username_2,
		arg.Author,
		arg.TweetID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimelineRow
	for rows.Next() {
		var i GetTimelineRow
		if err := rows.Scan(
			&i.Tweet.TweetID,
			&i.Tweet.Author,
			&i.Tweet.Content,
			&i.Tweet.Created,
			&i.Tweet.LikeCount,
			&i.Likedbyuser,
			&i.Bookmarkedbyuser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTweet = `-- name: GetTweet :one
SELECT tweets.tweet_id, tweets.author, tweets.content, tweets.created, tweets.like_count, likes.username IS NOT NULL AS likedByUser, bookmarks.username IS NOT NULL AS bookmarkedByUser
FROM tweets
LEFT JOIN likes ON likes.username = ? AND tweets.tweet_id = likes.tweet_id
LEFT JOIN bookmarks ON bookmarks.username = ? AND tweets.tweet_id = bookmarks.tweet_id
WHERE tweets.tweet_id = ?
LIMIT 1
`

type GetTweetParams struct {
	Username   string
	Username_2 string
	TweetID    int64
}

type GetTweetRow struct {
	Tweet            Tweet
	Likedbyuser      bool
	Bookmarkedbyuser bool
}

func (q *Queries) GetTweet(ctx context.Context, arg GetTweetParams) (GetTweetRow, error) {
	row := q.db.QueryRowContext(ctx, getTweet, arg.Username, arg.Username_2, arg.TweetID)
	var i GetTweetRow
	err := row.Scan(
		&i.Tweet.TweetID,
		&i.Tweet.Author,
		&i.Tweet.Content,
		&i.Tweet.Created,
		&i.Tweet.LikeCount,
		&i.Likedbyuser,
		&i.Bookmarkedbyuser,
	)
	return i, err
}

const getTweetLikers = `-- name: GetTweetLikers :many
SELECT username FROM likes
WHERE tweet_id = ?
`

func (q *Queries) GetTweetLikers(ctx context.Context, tweetID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTweetLikers, tweetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var username string
		if err := rows.Scan(&username); err != nil {
			return nil, err
		}
		items = append(items, username)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const likeTweet = `-- name: LikeTweet :exec
INSERT INTO likes (username, tweet_id)
VALUES (?, ?)
`

type LikeTweetParams struct {
	Username string
	TweetID  int64
}

func (q *Queries) LikeTweet(ctx context.Context, arg LikeTweetParams) error {
	_, err := q.db.ExecContext(ctx, likeTweet, arg.Username, arg.TweetID)
	return err
}

const searchTweets = `-- name: SearchTweets :many
SELECT tweet_id, author, content, created, like_count FROM tweets
WHERE content LIKE ?
ORDER BY created DESC
`

func (q *Queries) SearchTweets(ctx context.Context, content string) ([]Tweet, error) {
	rows, err := q.db.QueryContext(ctx, searchTweets, content)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tweet
	for rows.Next() {
		var i Tweet
		if err := rows.Scan(
			&i.TweetID,
			&i.Author,
			&i.Content,
			&i.Created,
			&i.LikeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unbookmarkTweet = `-- name: UnbookmarkTweet :exec
DELETE FROM bookmarks
WHERE username = ?
AND tweet_id = ?
`

type UnbookmarkTweetParams struct {
	Username string
	TweetID  int64
}

func (q *Queries) UnbookmarkTweet(ctx context.Context, arg UnbookmarkTweetParams) error {
	_, err := q.db.ExecContext(ctx, unbookmarkTweet, arg.Username, arg.TweetID)
	return err
}

const unlikeTweet = `-- name: UnlikeTweet :exec
DELETE FROM likes
WHERE username = ?
AND tweet_id = ?
`

type UnlikeTweetParams struct {
	Username string
	TweetID  int64
}

func (q *Queries) UnlikeTweet(ctx context.Context, arg UnlikeTweetParams) error {
	_, err := q.db.ExecContext(ctx, unlikeTweet, arg.Username, arg.TweetID)
	return err
}
